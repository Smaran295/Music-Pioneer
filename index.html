<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JioSaavn Search and Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #search-container {
            margin-bottom: 20px;
        }
        #search-input {
            width: 70%;
            padding: 10px;
            font-size: 16px;
        }
        #search-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #results {
            margin-bottom: 20px;
        }
        .song-item {
            padding: 10px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
        }
        .song-item:hover {
            background-color: #f0f0f0;
        }
        #player {
            width: 100%;
        }
    </style>
</head>
<body>
    <h1>JioSaavn Song Search</h1>
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Enter song name or artist...">
        <button id="search-button" onclick="searchSongs()">Search</button>
    </div>
    <div id="results"></div>
    <audio id="player" controls></audio>

    <script>
        function searchSongs() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) {
                alert('Please enter a search query.');
                return;
            }

            const apiUrl = `https://annonymous-sage.vercel.app/api/search/songs?query=${encodeURIComponent(query)}&limit=20`;

            fetch(apiUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.data && data.data.results) {
                        displayResults(data.data.results);
                    } else {
                        document.getElementById('results').innerHTML = '<p>No results found or error in response.</p>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('results').innerHTML = '<p>Error fetching results. Please try again.</p>';
                });
        }

        function displayResults(songs) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            songs.forEach(song => {
                const songDiv = document.createElement('div');
                songDiv.className = 'song-item';
                songDiv.innerHTML = `
                    <strong>${song.name}</strong> - ${song.artists.primary.map(artist => artist.name).join(', ')}<br>
                    Album: ${song.album.name} | Duration: ${formatDuration(song.duration)} | Language: ${song.language}
                `;
                songDiv.onclick = () => playSong(song);
                resultsDiv.appendChild(songDiv);
            });
        }

        function playSong(song) {
            const player = document.getElementById('player');
            // Select the highest quality download URL (assuming last in array is highest, e.g., 320kbps)
            const downloadUrls = song.downloadUrl || [];
            const highestQualityUrl = downloadUrls.length > 0 ? downloadUrls[downloadUrls.length - 1].url : null;

            if (highestQualityUrl) {
                player.src = highestQualityUrl;
                player.play().catch(error => {
                    console.error('Error playing audio:', error);
                    alert('Unable to play the song. It might be restricted or the link expired.');
                });
            } else {
                alert('No download URL available for this song.');
            }
        }

        function formatDuration(seconds) {
            if (!seconds) return 'N/A';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }
    </script>
</body>
</html>
